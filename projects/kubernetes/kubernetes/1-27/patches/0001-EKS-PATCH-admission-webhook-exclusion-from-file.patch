From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Igor Velichkovich <igorveli@amazon.com>
Date: Wed, 21 Dec 2022 20:12:26 -0600
Subject: [PATCH] --EKS-PATCH-- admission webhook exclusion from file

Description:
* Allows for the bypassing of admission controller webhook for certain resources.

Upstream PR, Issue, KEP, etc. links:
* See below.

If this patch is based on an upstream commit, how (if at all) do this patch and the upstream source differ?
* N/A

If this patch's changes have not been added by upstream, why not?
* This patch has not been added by upstream, but work is being actively done to add the ability to filter webhooks. See:
    - KEP-3716 -- https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/3716-admission-webhook-match-conditions
    and https://github.com/kubernetes/enhancements/pull/3717
    - Tracking issue -- https://github.com/kubernetes/enhancements/issues/3716
    - Kubernetes PR #116261 -- https://github.com/kubernetes/kubernetes/pull/116261

Other patches related to this patch:
* None

Changes made to this patch after its initial creation and reasons for these changes:
* February 2, 2023 -- This patch replaced 0002-EKS-PATCH-Bypassed-admission-controller-webhook-for-.patch
(https://github.com/aws/eks-distro/blob/v1-22-eks-18/projects/kubernetes/kubernetes/1-22/patches/0002-EKS-PATCH-Bypassed-admission-controller-webhook-for-.patch).
The difference between this patch and its predecessor is that this patch allows for users to supply a config file that
defines which webhooks should be excluded. If this files is not provided, this patch and the previous one function the
same.

Kubernetes version this patch can be dropped:
* When the upstream efforts to implement these changes are merged.
* We can replace with new match using match conditions in 1.28+ or when match conditions become GA

Signed-off-by: Jyoti Mahapatra <jyotima@amazon.com>
---
 .../exclusionrules/critical_path_excluder.go  | 163 +++++
 .../critical_path_excluder_test.go            | 680 ++++++++++++++++++
 .../webhook/generic/exclusionrules/matcher.go |  91 +++
 .../generic/exclusionrules/matcher_test.go    | 412 +++++++++++
 .../plugin/webhook/generic/webhook.go         |  24 +
 .../webhook_exclusion_rules_test.go           | 283 ++++++++
 vendor/modules.txt                            |   1 +
 7 files changed, 1654 insertions(+)
 create mode 100644 staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder.go
 create mode 100644 staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder_test.go
 create mode 100644 staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher.go
 create mode 100644 staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher_test.go
 create mode 100644 test/integration/apiserver/admissionwebhook/webhook_exclusion_rules_test.go

diff --git a/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder.go b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder.go
new file mode 100644
index 00000000000..93a3952e301
--- /dev/null
+++ b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder.go
@@ -0,0 +1,163 @@
+package exclusionrules
+
+import (
+	"encoding/json"
+	"os"
+
+	v1 "k8s.io/api/admissionregistration/v1"
+	"k8s.io/apiserver/pkg/admission"
+	"k8s.io/klog/v2"
+)
+
+// Enables you to pass a config file to kube-api-server
+const ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR = "EKS_PATCH_EXCLUSION_RULES_FILE"
+
+type CriticalPathExcluder struct {
+	exclusionRules []ExclusionRule
+}
+
+type ExclusionRule struct {
+	// APIGroup is the API groups the resources belong to.
+	// Required.
+	APIGroup string `json:"apiGroup,omitempty"`
+
+	// APIVersions is the API versions the resources belong to.
+	// Required.
+	APIVersion string `json:"apiVersion,omitempty"`
+
+	// Name is a list of object names this rule applies to.
+	// '*' for name only allowed for Leases in kube-node-lease namespace otherwise rule is ignored
+	// Required.
+	Name []string `json:"name,omitempty"`
+
+	// Kind to exclude.
+	Kind string `json:"kind,omitempty"`
+
+	// Namespace is the namespaces this rule applies to.
+	Namespace string `json:"namespace,omitempty"`
+
+	// Scope specifies the scope of this rule.
+	// Valid values are "Cluster", "Namespaced"
+	// "Cluster" means that only cluster-scoped resources will match this rule.
+	// Namespace API objects are cluster-scoped.
+	// "Namespaced" means that only namespaced resources will match this rule.
+	// Namespace field required for "Namespaced" scope otherwise namespace field disallowed
+	Scope *v1.ScopeType `json:"scope,omitempty"`
+
+	// Username of the rbac user making the request
+	Username string `json:"username,omitempty"`
+}
+
+func NewCriticalPathExcluder() CriticalPathExcluder {
+	exclusionRulesFromFile := readFile()
+	filteredExclusionRules := filterValidRules(exclusionRulesFromFile)
+	return CriticalPathExcluder{
+		exclusionRules: filteredExclusionRules,
+	}
+}
+
+func readFile() []ExclusionRule {
+	data := []ExclusionRule{}
+	if fileLocation, ok := os.LookupEnv(ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR); ok {
+		file, err := os.ReadFile(fileLocation)
+		if err != nil {
+			klog.Errorf("Error reading %v file: %v", ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR, err)
+			return data
+		}
+		err = json.Unmarshal(file, &data)
+		if err != nil {
+			klog.Errorf("Error converting %v file to exclusion rules: %v", ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR, err)
+			return data
+		}
+		klog.Infof("Successfully found and loaded %v exclusion rules", len(data))
+		return data
+	}
+	return data
+}
+
+func filterValidRules(inputExclusionRules []ExclusionRule) []ExclusionRule {
+	// * only allowed for name if targeting leases in kube-node-lease
+	// * not allowed for Scope, APIVersion, APIGroup, Namespace or Kind
+	filteredRules := []ExclusionRule{}
+	for _, rule := range inputExclusionRules {
+		if rule.Scope == nil || rule.Username == "" || nilOrEmpty(rule.Name) || rule.Kind == "" || rule.APIVersion == "" {
+			klog.Errorf("Invalid webhook admission exclusion rule, missing required field of (Name, Kind, APIVersion, Username, Scope), skipping rule")
+			continue
+		}
+		// No namespace if cluster scoped
+		if *rule.Scope == v1.ClusterScope && rule.Namespace != "" {
+			klog.Errorf("Invalid webhook admission exclusion rule, cannot set namespace with Cluster Scope, skipping rule")
+			continue
+		}
+		// Required namespace if Namespaced scope
+		if *rule.Scope == v1.NamespacedScope && rule.Namespace == "" {
+			klog.Errorf("Invalid webhook admission exclusion rule, must set namespace with Namespaced Scope, skipping rule")
+			continue
+		}
+		if *rule.Scope == v1.AllScopes {
+			klog.Errorf("Invalid webhook admission exclusion rule, wildcard scope not allowed, skipping rule")
+			continue
+		}
+		if rule.APIGroup == "*" {
+			klog.Errorf("Invalid webhook admission exclusion rule, wildcard group not allowed, skipping rule")
+			continue
+		}
+
+		if rule.Namespace == "*" {
+			klog.Errorf("Invalid webhook admission exclusion rule, wildcard namespace not allowed, skipping rule")
+			continue
+		}
+
+		if rule.Kind == "*" {
+			klog.Errorf("Invalid webhook admission exclusion rule, wildcard kind not allowed, skipping rule")
+			continue
+		}
+
+		if rule.Username == "*" {
+			// if you restrict to a specific username you can wildcard resource name and apiversion
+			if contains(rule.Name, "*") && isDisallowedNameWildcard(rule) {
+				klog.Errorf("Invalid webhook admission exclusion rule, wildcard only allowed for name for Lease in kube-node-lease, skipping rule")
+				continue
+			}
+
+			if rule.APIVersion == "*" {
+				klog.Errorf("Invalid webhook admission exclusion rule, wildcard version not allowed without user selection, skipping rule")
+				continue
+			}
+		}
+
+		filteredRules = append(filteredRules, rule)
+	}
+	return filteredRules
+}
+
+func isDisallowedNameWildcard(rule ExclusionRule) bool {
+	return !(rule.APIGroup == "coordination.k8s.io" && rule.APIVersion == "v1" && rule.Kind == "Lease" && rule.Namespace == "kube-node-lease")
+}
+
+func contains(s []string, str string) bool {
+	for _, v := range s {
+		if v == str {
+			return true
+		}
+	}
+
+	return false
+}
+
+func nilOrEmpty(s []string) bool {
+	if s == nil || len(s) == 0 {
+		return true
+	}
+	return false
+}
+
+func (excludor CriticalPathExcluder) ShouldSkipWebhookDueToExclusionRules(attr admission.Attributes) bool {
+	for _, r := range excludor.exclusionRules {
+		m := Matcher{ExclusionRule: r, Attr: attr}
+		if m.Matches() {
+			return true
+		}
+	}
+	return false
+}
diff --git a/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder_test.go b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder_test.go
new file mode 100644
index 00000000000..2e491094d81
--- /dev/null
+++ b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/critical_path_excluder_test.go
@@ -0,0 +1,680 @@
+package exclusionrules
+
+import (
+	"testing"
+
+	v1 "k8s.io/api/admissionregistration/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apiserver/pkg/admission"
+	"k8s.io/apiserver/pkg/authentication/user"
+)
+
+func getAttributes() admission.Attributes {
+	return admission.NewAttributesRecord(
+		nil,
+		nil,
+		schema.GroupVersionKind{"apps", "v1", "Deployment"},
+		"ns",
+		"testName",
+		schema.GroupVersionResource{"apps", "v1", "deployments"},
+		"",
+		admission.Create,
+		&metav1.CreateOptions{},
+		false,
+		&user.DefaultInfo{
+			Name: "exempt:user",
+		},
+	)
+}
+
+func TestShouldSkipWebhookDueToExclusionRules(t *testing.T) {
+	namespace := v1.NamespacedScope
+	testcases := []struct {
+		name           string
+		exclusionRules []ExclusionRule
+		result         bool
+		attr           admission.Attributes
+	}{
+		{
+			name: "Matches attribute first exclusion rule",
+			exclusionRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "",
+					APIVersion: "v1",
+					Kind:       "Configmap",
+					Name:       []string{"mismatch"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			result: true,
+			attr:   getAttributes(),
+		},
+		{
+			name: "Matches attribute second exclusion rule",
+			exclusionRules: []ExclusionRule{
+				{
+					APIGroup:   "",
+					APIVersion: "v1",
+					Kind:       "Configmap",
+					Name:       []string{"mismatch"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			result: true,
+			attr:   getAttributes(),
+		},
+		{
+			name: "Does not match exclusion rules",
+			exclusionRules: []ExclusionRule{
+				{
+					APIGroup:   "",
+					APIVersion: "v1",
+					Kind:       "Configmap",
+					Name:       []string{"mismatch"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"mismatch"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			result: false,
+			attr:   getAttributes(),
+		},
+		{
+			name:           "No exclusion rules exist",
+			exclusionRules: []ExclusionRule{},
+			result:         false,
+			attr:           getAttributes(),
+		},
+	}
+	for _, testcase := range testcases {
+		t.Run(testcase.name, func(t *testing.T) {
+			criticalPathExcluder := CriticalPathExcluder{
+				exclusionRules: testcase.exclusionRules,
+			}
+			result := criticalPathExcluder.ShouldSkipWebhookDueToExclusionRules(testcase.attr)
+			if result != testcase.result {
+				t.Fatalf("Unexpected result %v for test case %v", result, testcase.name)
+			}
+		})
+	}
+}
+
+func TestFilterValidRules(t *testing.T) {
+	cluster := v1.ClusterScope
+	namespace := v1.NamespacedScope
+	allscopes := v1.AllScopes
+	testcases := []struct {
+		name                string
+		inputRules          []ExclusionRule
+		expectedOutputRules int
+	}{
+		{
+			name: "Allowed missing APIGroup for group \"\"",
+			inputRules: []ExclusionRule{
+				{
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 2,
+		},
+		{
+			name: "No missing APIVersion",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:  "v1",
+					Kind:      "Deployment",
+					Name:      []string{"testName"},
+					Namespace: "ns",
+					Scope:     &namespace,
+					Username:  "*",
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No missing KIND",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "v1",
+					APIVersion: "v1",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No empty KIND",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "v1",
+					APIVersion: "v1",
+					Kind:       "",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No missing Name",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "v1",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No empty Name",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "v1",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No missing username",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "v1",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"Deployment"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No wildcard for APIGroup",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "*",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "*",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "exempt:user",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No wildcard for APIVersion",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "*",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "*",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "exempt:user",
+				},
+			},
+			expectedOutputRules: 2,
+		},
+		{
+			name: "No wildcard for Kind",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "*",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "*",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "exempt:user",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No wildcard for Namespace",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "*",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "*",
+					Scope:      &namespace,
+					Username:   "exempt:user",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No Empty Scope",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No AllScopes",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &allscopes,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &allscopes,
+					Username:   "exempt:user",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No Name wildcard, not lease",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"*"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No Name wildcard, not kube-node-lease",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "coordination.k8s.io",
+					APIVersion: "v1",
+					Kind:       "Lease",
+					Name:       []string{"*"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No Name wildcard, not coordination.k8s.io",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "wrong",
+					APIVersion: "v1",
+					Kind:       "Lease",
+					Name:       []string{"*"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "No Name wildcard, not v1",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "coordination.k8s.io",
+					APIVersion: "v1beta1",
+					Kind:       "Lease",
+					Name:       []string{"*"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "Allowed name wildcard",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "coordination.k8s.io",
+					APIVersion: "v1",
+					Kind:       "Lease",
+					Name:       []string{"*"},
+					Namespace:  "kube-node-lease",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "test",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"*"},
+					Namespace:  "kube-node-lease",
+					Scope:      &namespace,
+					Username:   "exempt:user",
+				},
+			},
+			expectedOutputRules: 3,
+		},
+		{
+			name: "Cluster scoped does not allow namespace",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &cluster,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+		{
+			name: "Namespaced scoped requires namespace",
+			inputRules: []ExclusionRule{
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "ns",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+				{
+					APIGroup:   "apps",
+					APIVersion: "v1",
+					Kind:       "Deployment",
+					Name:       []string{"testName"},
+					Namespace:  "",
+					Scope:      &namespace,
+					Username:   "*",
+				},
+			},
+			expectedOutputRules: 1,
+		},
+	}
+	for _, testcase := range testcases {
+		t.Run(testcase.name, func(t *testing.T) {
+			result := filterValidRules(testcase.inputRules)
+			if len(result) != testcase.expectedOutputRules {
+				t.Fatalf("Unexpected result length of filtered rules %v for test case %v", len(result), testcase.name)
+			}
+		})
+	}
+}
diff --git a/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher.go b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher.go
new file mode 100644
index 00000000000..adbd9dd20b1
--- /dev/null
+++ b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher.go
@@ -0,0 +1,91 @@
+package exclusionrules
+
+import (
+	v1 "k8s.io/api/admissionregistration/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apiserver/pkg/admission"
+)
+
+var namespaceResource = schema.GroupVersionResource{Group: "", Version: "v1", Resource: "namespaces"}
+
+// Matcher determines if the Attr matches the Rule.
+type Matcher struct {
+	ExclusionRule ExclusionRule
+	Attr          admission.Attributes
+}
+
+// Matches returns if the Attr matches the Rule.
+func (r *Matcher) Matches() bool {
+	return r.name() &&
+		r.namespace() &&
+		r.group() &&
+		r.version() &&
+		r.kind() &&
+		r.username() &&
+		r.scope()
+}
+
+func exactOrWildcardList(items []string, requested string) bool {
+	for _, item := range items {
+		if item == "*" {
+			return true
+		}
+		if item == requested {
+			return true
+		}
+	}
+
+	return false
+}
+
+func exactOrWildcard(item string, requested string) bool {
+	return exactOrWildcardList([]string{item}, requested)
+}
+
+func (r *Matcher) scope() bool {
+	if r.ExclusionRule.Scope == nil || *r.ExclusionRule.Scope == v1.AllScopes {
+		// Not valid
+		return false
+	}
+	// attr.GetNamespace() is set to the name of the namespace for requests of the namespace object itself.
+	switch *r.ExclusionRule.Scope {
+	case v1.NamespacedScope:
+		// first make sure that we are not requesting a namespace object (namespace objects are cluster-scoped)
+		// this will return true for a resource that has a namespace and is not a Namespace itself
+		// i.e. true for Deployment and Role
+		//      false for Namespace and ClusterRole
+		return r.Attr.GetResource() != namespaceResource && r.Attr.GetNamespace() != metav1.NamespaceNone
+	case v1.ClusterScope:
+		// also return true if the request is for a namespace object (namespace objects are cluster-scoped)
+		// i.e. false for Deployment and Role
+		//      true for Namespace and ClusterRole
+		return r.Attr.GetResource() == namespaceResource || r.Attr.GetNamespace() == metav1.NamespaceNone
+	default:
+		return false
+	}
+}
+
+func (r *Matcher) group() bool {
+	return r.ExclusionRule.APIGroup == r.Attr.GetResource().Group
+}
+
+func (r *Matcher) name() bool {
+	return exactOrWildcardList(r.ExclusionRule.Name, r.Attr.GetName())
+}
+
+func (r *Matcher) namespace() bool {
+	return r.ExclusionRule.Namespace == r.Attr.GetNamespace()
+}
+
+func (r *Matcher) version() bool {
+	return exactOrWildcard(r.ExclusionRule.APIVersion, r.Attr.GetResource().Version)
+}
+
+func (r *Matcher) kind() bool {
+	return r.ExclusionRule.Kind == r.Attr.GetKind().Kind
+}
+
+func (r *Matcher) username() bool {
+	return exactOrWildcard(r.ExclusionRule.Username, r.Attr.GetUserInfo().GetName())
+}
diff --git a/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher_test.go b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher_test.go
new file mode 100644
index 00000000000..9925764a5b9
--- /dev/null
+++ b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules/matcher_test.go
@@ -0,0 +1,412 @@
+package exclusionrules
+
+import (
+	"fmt"
+	"testing"
+
+	adreg "k8s.io/api/admissionregistration/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/util/sets"
+	"k8s.io/apiserver/pkg/admission"
+	"k8s.io/apiserver/pkg/authentication/user"
+)
+
+type exclusionRuleTest struct {
+	exclusionRule ExclusionRule
+	match         []admission.Attributes
+	noMatch       []admission.Attributes
+}
+type tests map[string]exclusionRuleTest
+
+func attrList(a ...admission.Attributes) []admission.Attributes {
+	return a
+}
+
+func a(group, version, kind, namespace, name, username string) admission.Attributes {
+	return admission.NewAttributesRecord(
+		nil, nil,
+		schema.GroupVersionKind{Group: group, Version: version, Kind: kind},
+		namespace, name,
+		schema.GroupVersionResource{Group: group, Version: version, Resource: ""}, "",
+		"",
+		nil,
+		false,
+		&user.DefaultInfo{
+			Name: username,
+		},
+	)
+}
+
+func namespacedAttributes(group, version, resource, subresource, name string, operation admission.Operation, operationOptions runtime.Object) admission.Attributes {
+	return admission.NewAttributesRecord(
+		nil, nil,
+		schema.GroupVersionKind{Group: group, Version: version, Kind: "k" + resource},
+		"ns", name,
+		schema.GroupVersionResource{Group: group, Version: version, Resource: resource}, subresource,
+		operation,
+		operationOptions,
+		false,
+		nil,
+	)
+}
+
+func clusterScopedAttributes(group, version, resource, subresource, name string, operation admission.Operation, operationOptions runtime.Object) admission.Attributes {
+	return admission.NewAttributesRecord(
+		nil, nil,
+		schema.GroupVersionKind{Group: group, Version: version, Kind: "k" + resource},
+		"", name,
+		schema.GroupVersionResource{Group: group, Version: version, Resource: resource}, subresource,
+		operation,
+		operationOptions,
+		false,
+		nil,
+	)
+}
+
+func TestGroup(t *testing.T) {
+	table := tests{
+		"wildcard": {
+			exclusionRule: ExclusionRule{
+				APIGroup: "*",
+			},
+			noMatch: attrList(
+				a("g1", "v1", "Lease", "test", "kube-scheduler", "test:user"),
+			),
+		},
+		"exact": {
+			exclusionRule: ExclusionRule{
+				APIGroup: "g1",
+			},
+			match: attrList(
+				a("g1", "v", "r", "", "name", "test:user"),
+				a("g1", "v2", "r3", "", "name", "test:user"),
+			),
+			noMatch: attrList(
+				a("g3", "v", "r", "", "name", "test:user"),
+				a("g4", "v", "r", "", "name", "test:user"),
+			),
+		},
+	}
+
+	for name, tt := range table {
+		for i, m := range tt.match {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if !r.group() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+		for i, m := range tt.noMatch {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if r.group() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+	}
+}
+
+func TestVersion(t *testing.T) {
+	table := tests{
+		"wildcard": {
+			exclusionRule: ExclusionRule{
+				APIVersion: "*",
+			},
+			match: attrList(
+				a("g1", "v1", "Lease", "", "kube-scheduler", "test:user"),
+			),
+		},
+		"exact": {
+			exclusionRule: ExclusionRule{
+				APIVersion: "v1",
+			},
+			match: attrList(
+				a("g1", "v1", "r", "", "name", "test:user"),
+				a("g2", "v1", "r", "", "name", "test:user"),
+			),
+			noMatch: attrList(
+				a("g1", "v3", "r", "", "name", "test:user"),
+				a("g2", "v4", "r", "", "name", "test:user"),
+			),
+		},
+	}
+	for name, tt := range table {
+		for i, m := range tt.match {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if !r.version() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+		for i, m := range tt.noMatch {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if r.version() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+	}
+}
+
+func TestKind(t *testing.T) {
+	table := tests{
+		"wildcard": {
+			exclusionRule: ExclusionRule{
+				Kind: "*",
+			},
+			noMatch: attrList(
+				a("g1", "v1", "Lease", "test", "kube-scheduler", "test:user"),
+			),
+		},
+		"exact": {
+			exclusionRule: ExclusionRule{
+				Kind: "Lease",
+			},
+			match: attrList(
+				a("g1", "v1", "Lease", "", "name", "test:user"),
+				a("g2", "v2", "Lease", "", "name", "test:user"),
+			),
+			noMatch: attrList(
+				a("g1", "v3", "Deployment", "", "name", "test:user"),
+				a("g2", "v4", "Pod", "", "name", "test:user"),
+			),
+		},
+	}
+	for name, tt := range table {
+		for i, m := range tt.match {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if !r.kind() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+		for i, m := range tt.noMatch {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if r.kind() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+	}
+}
+
+func TestName(t *testing.T) {
+	table := tests{
+		"wildcard": {
+			exclusionRule: ExclusionRule{
+				Name: []string{"*"},
+			},
+			match: attrList(
+				a("g1", "v1", "Lease", "", "kube-scheduler", "test:user"),
+			),
+		},
+		"exact": {
+			exclusionRule: ExclusionRule{
+				Name: []string{"kube-scheduler"},
+			},
+			match: attrList(
+				a("g1", "v1", "Lease", "", "kube-scheduler", "test:user"),
+				a("g2", "v2", "Lease", "", "kube-scheduler", "test:user"),
+			),
+			noMatch: attrList(
+				a("g1", "v3", "Deployment", "", "something", "test:user"),
+				a("g2", "v4", "Pod", "", "else", "test:user"),
+			),
+		},
+	}
+	for name, tt := range table {
+		for i, m := range tt.match {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if !r.name() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+		for i, m := range tt.noMatch {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if r.name() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+	}
+}
+
+func TestUserName(t *testing.T) {
+	table := tests{
+		"wildcard": {
+			exclusionRule: ExclusionRule{
+				Username: "*",
+			},
+			match: attrList(
+				a("g1", "v1", "Lease", "", "kube-scheduler", "test:user"),
+			),
+		},
+		"exact": {
+			exclusionRule: ExclusionRule{
+				Username: "exempt:user",
+			},
+			match: attrList(
+				a("g1", "v1", "Lease", "", "kube-scheduler", "exempt:user"),
+				a("g2", "v2", "Lease", "", "kube-scheduler", "exempt:user"),
+			),
+			noMatch: attrList(
+				a("g1", "v3", "Deployment", "", "something", "test:user1"),
+				a("g2", "v4", "Pod", "", "else", "test:user2"),
+			),
+		},
+	}
+	for name, tt := range table {
+		for i, m := range tt.match {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if !r.username() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+		for i, m := range tt.noMatch {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if r.username() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+	}
+}
+
+func TestNamespace(t *testing.T) {
+	table := tests{
+		"wildcard": {
+			exclusionRule: ExclusionRule{
+				Namespace: "*",
+			},
+			noMatch: attrList(
+				a("g1", "v1", "Lease", "test", "kube-scheduler", "test:user"),
+			),
+		},
+		"exact": {
+			exclusionRule: ExclusionRule{
+				Namespace: "kube-system",
+			},
+			match: attrList(
+				a("g1", "v1", "Lease", "kube-system", "", "test:user"),
+				a("g2", "v2", "Endpoint", "kube-system", "", "test:user"),
+			),
+			noMatch: attrList(
+				a("g1", "v3", "Deployment", "something", "something", "test:user"),
+				a("g2", "v4", "Pod", "else", "else", "test:user"),
+			),
+		},
+	}
+	for name, tt := range table {
+		for i, m := range tt.match {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if !r.namespace() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+		for i, m := range tt.noMatch {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if r.namespace() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+	}
+}
+
+func TestScope(t *testing.T) {
+	cluster := adreg.ClusterScope
+	namespace := adreg.NamespacedScope
+	allscopes := adreg.AllScopes
+	table := tests{
+		"cluster scope": {
+			exclusionRule: ExclusionRule{
+				Scope: &cluster,
+			},
+			match: attrList(
+				clusterScopedAttributes("g", "v", "r", "", "name", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("g", "v", "r", "exec", "name", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("", "v1", "namespaces", "", "ns", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("", "v1", "namespaces", "finalize", "ns", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("", "v1", "namespaces", "", "ns", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("", "v1", "namespaces", "finalize", "ns", admission.Create, &metav1.CreateOptions{}),
+			),
+			noMatch: attrList(
+				namespacedAttributes("g", "v", "r", "", "name", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("g", "v", "r", "exec", "name", admission.Create, &metav1.CreateOptions{}),
+			),
+		},
+		"namespace scope": {
+			exclusionRule: ExclusionRule{
+				Scope: &namespace,
+			},
+			match: attrList(
+				namespacedAttributes("g", "v", "r", "", "name", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("g", "v", "r", "exec", "name", admission.Create, &metav1.CreateOptions{}),
+			),
+			noMatch: attrList(
+				clusterScopedAttributes("", "v1", "namespaces", "", "ns", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("", "v1", "namespaces", "finalize", "ns", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("", "v1", "namespaces", "", "ns", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("", "v1", "namespaces", "finalize", "ns", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("g", "v", "r", "", "name", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("g", "v", "r", "exec", "name", admission.Create, &metav1.CreateOptions{}),
+			),
+		},
+		"all scopes": {
+			exclusionRule: ExclusionRule{
+				Scope: &allscopes,
+			},
+			noMatch: attrList(
+				namespacedAttributes("g", "v", "r", "", "name", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("g", "v", "r", "exec", "name", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("g", "v", "r", "", "name", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("g", "v", "r", "exec", "name", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("", "v1", "namespaces", "", "ns", admission.Create, &metav1.CreateOptions{}),
+				clusterScopedAttributes("", "v1", "namespaces", "finalize", "ns", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("", "v1", "namespaces", "", "ns", admission.Create, &metav1.CreateOptions{}),
+				namespacedAttributes("", "v1", "namespaces", "finalize", "ns", admission.Create, &metav1.CreateOptions{}),
+			),
+			match: attrList(),
+		},
+	}
+	keys := sets.NewString()
+	for name := range table {
+		keys.Insert(name)
+	}
+	for _, name := range keys.List() {
+		tt := table[name]
+		for i, m := range tt.match {
+			t.Run(fmt.Sprintf("%s_match_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if !r.scope() {
+					t.Errorf("%v: expected match %#v", name, m)
+				}
+			})
+		}
+		for i, m := range tt.noMatch {
+			t.Run(fmt.Sprintf("%s_nomatch_%d", name, i), func(t *testing.T) {
+				r := Matcher{tt.exclusionRule, m}
+				if r.scope() {
+					t.Errorf("%v: expected no match %#v", name, m)
+				}
+			})
+		}
+	}
+}
diff --git a/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/webhook.go b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/webhook.go
index a5828983112..c1117469c38 100644
--- a/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/webhook.go
+++ b/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/webhook.go
@@ -20,6 +20,8 @@ import (
 	"context"
 	"fmt"
 	"io"
+	"k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules"
+	"sync"
 
 	admissionv1 "k8s.io/api/admission/v1"
 	admissionv1beta1 "k8s.io/api/admission/v1beta1"
@@ -41,6 +43,20 @@ import (
 	"k8s.io/klog/v2"
 )
 
+var criticalPathExcluder exclusionrules.CriticalPathExcluder
+var LoadCriticalPathExcluder *sync.Once
+
+func init() {
+	// We are using a pointer to sync.Once in order to "reset" the sync.Once within our integration tests
+	// so that when the integration test api-server starts up, sync.Once has not been exhausted
+	// this is required because LoadCriticalPathExcluder is a global variable and when a suite of tests run
+	// the first test that starts an api-server will use up the sync.Once and subsequent launches of the api-server will
+	// not try to load the exclusion rules.
+	// see: test/integration/apiserver/admissionwebhook/webhook_exclusion_rules_test.go
+	// see: https://github.com/golang/go/issues/25955#issuecomment-398278056
+	LoadCriticalPathExcluder = new(sync.Once)
+}
+
 // Webhook is an abstract admission plugin with all the infrastructure to define Admit or Validate on-top.
 type Webhook struct {
 	*admission.Handler
@@ -90,6 +106,10 @@ func NewWebhook(handler *admission.Handler, configFile io.Reader, sourceFactory
 	cm.SetAuthenticationInfoResolver(authInfoResolver)
 	cm.SetServiceResolver(webhookutil.NewDefaultServiceResolver())
 
+	LoadCriticalPathExcluder.Do(func() {
+		criticalPathExcluder = exclusionrules.NewCriticalPathExcluder()
+	})
+
 	return &Webhook{
 		Handler:          handler,
 		sourceFactory:    sourceFactory,
@@ -163,6 +183,10 @@ func (a *Webhook) ShouldCallHook(ctx context.Context, h webhook.WebhookAccessor,
 		return nil, nil
 	}
 
+	if criticalPathExcluder.ShouldSkipWebhookDueToExclusionRules(attr) {
+		return nil, nil
+	}
+
 	var invocation *WebhookInvocation
 	for _, r := range h.GetRules() {
 		m := rules.Matcher{Rule: r, Attr: attr}
diff --git a/test/integration/apiserver/admissionwebhook/webhook_exclusion_rules_test.go b/test/integration/apiserver/admissionwebhook/webhook_exclusion_rules_test.go
new file mode 100644
index 00000000000..2c26ca24870
--- /dev/null
+++ b/test/integration/apiserver/admissionwebhook/webhook_exclusion_rules_test.go
@@ -0,0 +1,283 @@
+package admissionwebhook
+
+import (
+	"context"
+	"fmt"
+	"os"
+	"sync"
+	"testing"
+	"time"
+
+	coordinationv1 "k8s.io/api/coordination/v1"
+	"k8s.io/apiserver/pkg/admission/plugin/webhook/generic"
+	"k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules"
+
+	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
+	appsv1 "k8s.io/api/apps/v1"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/kubernetes"
+	kubeapiservertesting "k8s.io/kubernetes/cmd/kube-apiserver/app/testing"
+	"k8s.io/kubernetes/test/integration/framework"
+)
+
+var (
+	exclusionRulesFile           = "exclusion-rules-config.json"
+	webhookNameExclusionRules    = "integration-exclusion-rules-test-webhook-config"
+	deploymentNameExclusionRules = "integration-exclusion-rules-test-deployment"
+	kubeSystem                   = "kube-system"
+	kubeControllerManager        = "kube-controller-manager"
+	kubeScheduler                = "kube-scheduler"
+)
+
+func TestWebhookExclusionRulesNoEnvVarSet(t *testing.T) {
+	generic.LoadCriticalPathExcluder = new(sync.Once) //reset sync.Once to force behavior of new startup https://github.com/golang/go/issues/25955#issuecomment-398278056
+	t.Logf("starting server")
+	server := kubeapiservertesting.StartTestServerOrDie(t, nil, nil, framework.SharedEtcd())
+	defer server.TearDownFn()
+
+	client, err := kubernetes.NewForConfig(server.ClientConfig)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+	createBrokenWebhook(t, client)
+	// Creating deployment that should be blocked by webhook
+	_, err = client.AppsV1().Deployments("default").Create(context.TODO(), exampleDeploymentExclusionRules(deploymentNameExclusionRules), metav1.CreateOptions{})
+	if err == nil {
+		t.Fatalf("was able to create deployment but should've been blocked: %v", err)
+	}
+	// Default rules should be set
+	validateDefaultExclusionRulesSet(t, client)
+}
+
+func TestWebhookExclusionRulesEnvVarSetNoFile(t *testing.T) {
+	generic.LoadCriticalPathExcluder = new(sync.Once) //reset sync.Once to force behavior of new startup https://github.com/golang/go/issues/25955#issuecomment-398278056
+	server := kubeapiservertesting.StartTestServerOrDie(t, nil, nil, framework.SharedEtcd())
+	defer server.TearDownFn()
+
+	client, err := kubernetes.NewForConfig(server.ClientConfig)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	// Test env var set but no file, should be broken webhook
+	err = os.Setenv(exclusionrules.ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR, exclusionRulesFile)
+	if err != nil {
+		t.Fatalf("unexpected error clearing %v env var", exclusionrules.ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR)
+	}
+
+	createBrokenWebhook(t, client)
+
+	//Creating deployment that should be blocked by webhook
+	_, err = client.AppsV1().Deployments("default").Create(context.TODO(), exampleDeploymentExclusionRules(deploymentNameExclusionRules), metav1.CreateOptions{})
+	if err == nil {
+		t.Fatalf("was able to create deployment but should've been blocked: %v", err)
+	}
+	// Default rules should be set
+	validateDefaultExclusionRulesSet(t, client)
+}
+
+func TestWebhookExclusionRulesEnvVarSetBadFile(t *testing.T) {
+	generic.LoadCriticalPathExcluder = new(sync.Once) //reset sync.Once to force behavior of new startup https://github.com/golang/go/issues/25955#issuecomment-398278056
+	// Test env var set, bad file, should be broken webhook
+	err := os.Setenv(exclusionrules.ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR, exclusionRulesFile)
+	if err != nil {
+		t.Fatalf("unexpected error clearing %v env var", exclusionrules.ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR)
+	}
+
+	if err := os.WriteFile(exclusionRulesFile, []byte("bad file"), os.FileMode(0755)); err != nil {
+		t.Fatal(err)
+	}
+	defer os.Remove(exclusionRulesFile)
+
+	server := kubeapiservertesting.StartTestServerOrDie(t, nil, nil, framework.SharedEtcd())
+	defer server.TearDownFn()
+
+	client, err := kubernetes.NewForConfig(server.ClientConfig)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+	createBrokenWebhook(t, client)
+
+	//Creating deployment that should be blocked by webhook
+	_, err = client.AppsV1().Deployments("default").Create(context.TODO(), exampleDeploymentExclusionRules(deploymentNameExclusionRules), metav1.CreateOptions{})
+	if err == nil {
+		t.Fatalf("was able to create deployment but should've been blocked: %v", err)
+	}
+	// Default rules should be set
+	validateDefaultExclusionRulesSet(t, client)
+}
+
+func TestWebhookExclusionRules(t *testing.T) {
+	generic.LoadCriticalPathExcluder = new(sync.Once) //reset sync.Once to force behavior of new startup https://github.com/golang/go/issues/25955#issuecomment-398278056
+	err := os.Setenv(exclusionrules.ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR, exclusionRulesFile)
+	if err != nil {
+		t.Fatalf("unexpected error clearing %v env var", exclusionrules.ADMISSION_WEBHOOK_EXCLUSION_ENV_VAR)
+	}
+
+	//test env var set, exclusion file should exclude
+	configFile := fmt.Sprintf(`
+[
+	{
+		"apiGroup": "apps",
+		"apiVersion": "v1",
+		"kind": "Deployment",
+		"namespace": "default",
+		"name": ["%v"],
+		"scope": "Namespaced",
+		"username": "*"
+	}
+]`, deploymentNameExclusionRules)
+
+	if err := os.WriteFile(exclusionRulesFile, []byte(configFile), os.FileMode(0755)); err != nil {
+		t.Fatal(err)
+	}
+	defer os.Remove(exclusionRulesFile)
+
+	server := kubeapiservertesting.StartTestServerOrDie(t, nil, nil, framework.SharedEtcd())
+	defer server.TearDownFn()
+
+	client, err := kubernetes.NewForConfig(server.ClientConfig)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	createBrokenWebhook(t, client)
+
+	t.Logf("Creating Deployment which should be allowed due to exclusion rules")
+	_, err = client.AppsV1().Deployments("default").Create(context.TODO(), exampleDeploymentExclusionRules(deploymentNameExclusionRules), metav1.CreateOptions{})
+	if err != nil {
+		t.Fatalf("Failed to create deployment: %v", err)
+	}
+
+	t.Logf("Creating Deployment with different name which should be blocked due to webhook")
+	_, err = client.AppsV1().Deployments("default").Create(context.TODO(), exampleDeploymentExclusionRules("test-different-name"), metav1.CreateOptions{})
+	if err == nil {
+		t.Fatalf("was able to create deployment but should've been blocked: %v", err)
+	}
+}
+
+func validateDefaultExclusionRulesSet(t *testing.T, client *kubernetes.Clientset) {
+	_, err := client.CoreV1().Endpoints("kube-system").Create(context.TODO(), exampleEndpoints(kubeControllerManager), metav1.CreateOptions{})
+	if err != nil {
+		t.Fatalf("was not able to create endpoint but should've been allowed: %v", err)
+	}
+	_, err = client.CoreV1().Endpoints("kube-system").Create(context.TODO(), exampleEndpoints(kubeScheduler), metav1.CreateOptions{})
+	if err != nil {
+		t.Fatalf("was not able to create endpoint but should've been allowed: %v", err)
+	}
+	_, err = client.CoordinationV1().Leases("kube-system").Create(context.TODO(), exampleLease(kubeControllerManager), metav1.CreateOptions{})
+	if err != nil {
+		t.Fatalf("was not able to create lease but should've been allowed: %v", err)
+	}
+	_, err = client.CoordinationV1().Leases("kube-system").Create(context.TODO(), exampleLease(kubeScheduler), metav1.CreateOptions{})
+	if err != nil {
+		t.Fatalf("was not able to create lease but should've been allowed: %v", err)
+	}
+}
+
+func createBrokenWebhook(t *testing.T, client *kubernetes.Clientset) {
+	t.Logf("Creating Broken Webhook that will block all operations on all objects")
+	brokenWebhook := brokenWebhookConfigExclusionRules(webhookNameExclusionRules)
+	_, err := client.AdmissionregistrationV1().ValidatingWebhookConfigurations().Create(context.TODO(), brokenWebhook, metav1.CreateOptions{})
+	if err != nil {
+		t.Fatalf("Failed to register broken webhook: %v", err)
+	}
+
+	for i := 0; i < 10; i++ {
+		time.Sleep(2 * time.Second)
+		_, err := client.AdmissionregistrationV1().ValidatingWebhookConfigurations().Get(context.TODO(), brokenWebhook.Name, metav1.GetOptions{})
+		if err == nil {
+			t.Log("Successfully registered broken webhook")
+			return
+		}
+	}
+	t.Fatal("Timed out waiting for test bad webhook to create")
+}
+
+func exampleDeploymentExclusionRules(name string) *appsv1.Deployment {
+	var replicas int32 = 1
+	return &appsv1.Deployment{
+		TypeMeta: metav1.TypeMeta{
+			Kind:       "Deployment",
+			APIVersion: "apps/v1",
+		},
+		ObjectMeta: metav1.ObjectMeta{
+			Namespace: "default",
+			Name:      name,
+		},
+		Spec: appsv1.DeploymentSpec{
+			Replicas: &replicas,
+			Selector: &metav1.LabelSelector{
+				MatchLabels: map[string]string{"foo": "bar"},
+			},
+			Template: corev1.PodTemplateSpec{
+				ObjectMeta: metav1.ObjectMeta{
+					Labels: map[string]string{"foo": "bar"},
+				},
+				Spec: corev1.PodSpec{
+					Containers: []corev1.Container{
+						{
+							Name:  "foo",
+							Image: "foo",
+						},
+					},
+				},
+			},
+		},
+	}
+}
+
+func exampleEndpoints(name string) *corev1.Endpoints {
+	return &corev1.Endpoints{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      name,
+			Namespace: kubeSystem,
+		},
+	}
+}
+
+func exampleLease(name string) *coordinationv1.Lease {
+	return &coordinationv1.Lease{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      name,
+			Namespace: kubeSystem,
+		},
+	}
+}
+
+func brokenWebhookConfigExclusionRules(name string) *admissionregistrationv1.ValidatingWebhookConfiguration {
+	var path string
+	failurePolicy := admissionregistrationv1.Fail
+	return &admissionregistrationv1.ValidatingWebhookConfiguration{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: name,
+		},
+		Webhooks: []admissionregistrationv1.ValidatingWebhook{
+			{
+				Name: "broken-webhook.k8s.io",
+				Rules: []admissionregistrationv1.RuleWithOperations{{
+					Operations: []admissionregistrationv1.OperationType{admissionregistrationv1.OperationAll},
+					Rule: admissionregistrationv1.Rule{
+						APIGroups:   []string{"*"},
+						APIVersions: []string{"*"},
+						Resources:   []string{"deployments"},
+					},
+				}},
+				// This client config references a non existent service
+				// so it should always fail.
+				ClientConfig: admissionregistrationv1.WebhookClientConfig{
+					Service: &admissionregistrationv1.ServiceReference{
+						Namespace: "default",
+						Name:      "invalid-webhook-service",
+						Path:      &path,
+					},
+					CABundle: nil,
+				},
+				FailurePolicy:           &failurePolicy,
+				SideEffects:             &noSideEffects,
+				AdmissionReviewVersions: []string{"v1"},
+			},
+		},
+	}
+}
diff --git a/vendor/modules.txt b/vendor/modules.txt
index c5ad2ad8a13..dd54c25b053 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -1415,6 +1415,7 @@ k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1
 k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1alpha1
 k8s.io/apiserver/pkg/admission/plugin/webhook/errors
 k8s.io/apiserver/pkg/admission/plugin/webhook/generic
+k8s.io/apiserver/pkg/admission/plugin/webhook/generic/exclusionrules
 k8s.io/apiserver/pkg/admission/plugin/webhook/initializer
 k8s.io/apiserver/pkg/admission/plugin/webhook/matchconditions
 k8s.io/apiserver/pkg/admission/plugin/webhook/mutating
